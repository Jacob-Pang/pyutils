from multiprocessing import Semaphore
from multiprocessing.managers import ListProxy, SyncManager

from pyutils.task_scheduler.resource.base import ResourceBase

class ResourceManagerProxy:
    def __init__(self, update_end_of_usage_queue: ListProxy) -> None:
        self._update_end_of_usage_queue = update_end_of_usage_queue

    def update_end_of_usage(self, allocated_keys: dict, resource_usage: dict) -> None:
        self._update_end_of_usage_queue.append(
            (allocated_keys, resource_usage)
        )

class ResourceManager (ResourceManagerProxy):
    def __init__(self, sync_manager: SyncManager) -> None:
        ResourceManagerProxy.__init__(self, sync_manager.list())

        self._resources = dict()
        self._resource_sem = dict()
        self._queued_usage = dict()

    def add_resources(self, *resources: ResourceBase):
        for resource in resources:
            self._resources[resource.key] = resource
            self._resource_sem[resource.key] = Semaphore(1)
            self._queued_usage[resource.key] = 0

    def use_or_queue_resources(self, resource_usage: dict, resource_constraints: set) -> dict:
        """ Attempt to allocate and use resources, returning the keys generated by the use of
        the resources. If unable to allocate resources due to insufficient capacity, populates
        resource constraints instead.

        Parameters:
        :resource_usage (dict): The mapping of resource_key: capacity_usage (see Task).
        :resource_constraints (set): A set to populate with the resource_keys of constrained
                resources. An empty set can be interpreted as a successful allocation.
        
        Returns:
        :allocated_keys (dict | None): The mapping of allocated resource_key: generated_key
                upon successful allocation, and None otherwise.
        """
        for resource_key, usage in resource_usage.items():
            self._resource_sem.get(resource_key).acquire()

            if not self._resources.get(resource_key).has_free_capacity(usage + self._queued_usage
                    .get(resource_key)):
                
                resource_constraints.add(resource_key)
                self._queued_usage[resource_key] += usage

        if resource_constraints:
            for resource_key in resource_usage:
                self._resource_sem.get(resource_key).release()

            return None

        allocated_keys = dict()

        for resource_key, usage in resource_usage.items():
            allocated_keys[resource_key] = self._resources.get(resource_key).use(usage)
            self._resource_sem.get(resource_key).release()

        return allocated_keys

    def use_from_queued_resources(self, resource_usage: dict, resource_constraints: set) -> dict:
        """ Atttempt to allocate and use resources, returning the keys generated by the use of
        the resources. This method assumes that there was prior allocation failure, and the usage
        has already been queued (see use_or_queue_resources).
        """
        freed_resources = set()

        for resource_key in resource_constraints:
            self._resource_sem.get(resource_key).acquire()
            usage = resource_usage.get(resource_key)

            if self._resources.get(resource_key).has_free_capacity(usage):
                freed_resources.add(resource_key)

        for resource_key in freed_resources:
            resource_constraints.remove(resource_key)

        if resource_constraints: # Outstanding constraints
            for resource_key in resource_constraints:
                self._resource_sem.get(resource_key).release()

            for resource_key in freed_resources:
                self._resource_sem.get(resource_key).release()

            return None

        allocated_keys = dict()

        for resource_key, usage in resource_usage.items():
            if resource_key not in freed_resources:
                self._resource_sem.get(resource_key).acquire()

            allocated_keys[resource_key] = self._resources.get(resource_key).use(usage)
            self._queued_usage[resource_key] -= usage
            self._resource_sem.get(resource_key).release()
            
        return allocated_keys

    def update(self) -> set:
        # Returns the set of resource_keys for which the resource has undergone changes in state.
        updated_resources = set()

        while self._update_end_of_usage_queue:
            allocated_keys, resource_usage = self._update_end_of_usage_queue.pop()

            for resource_key, allocated_key in allocated_keys.items():
                usage = resource_usage.get(resource_key)

                with self._resource_sem.get(resource_key):
                    self._resources.get(resource_key).free(allocated_key, usage)
                    updated_resources.add(resource_key)

        for resource_key, resource in self._resources.items():
            if resource.update():
                updated_resources.add(resource_key)

        return updated_resources

    def get_timeout_to_update(self) -> float:
        timeout = None

        for resource in self._resources.values():
            _timeout = resource.get_timeout_to_update()

            if not _timeout:
                continue

            if not timeout or _timeout < timeout:
                timeout = _timeout

        return timeout

    def as_proxy(self) -> ResourceManagerProxy:
        return ResourceManagerProxy(self._update_end_of_usage_queue)

    def __repr__(self) -> str:
        return "\n".join([
            str(resource) for resource in self._resources.values()
        ])

if __name__ == "__main__":
    pass