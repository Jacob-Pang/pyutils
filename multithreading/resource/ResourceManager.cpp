#include "ResourceManager.hpp"

ResourceManager::ResourceManager() {};

int ResourceManager::getTimeToNextUpdate() const {
    int minTime = 300; // default update frequency

    for (auto const& [ID, resource]: this->resources) {
        int time = resource.getTimeToNextUpdate();

        if (time < minTime)
            minTime = time;
    }

    return minTime;
};

void ResourceManager::registerResource(ResourceProxy& resource) {
    this->resources[resource.getID()] = resource;
};

void ResourceManager::registerResource(const std::string& ID, Resource& resource) {
    if (this->resources.count(ID)) {
        this->resources[ID].registerResource(resource);
    } else {
        ResourceProxy proxy = ResourceProxy(ID);
        proxy.registerResource(resource);
        ResourceManager::registerResource(proxy);
    }
};

void ResourceManager::recordFreedResources(const std::unordered_map<std::string, unsigned int>& usage,
        const std::unordered_map<std::string, size_t>& assignedKeys) {
    
    this->freeUsageSem.acquire();

    for (const auto& [ID, units]: usage) {
        this->freedUsage[std::make_pair(ID, assignedKeys.at(ID))] += units;
    }

    this->freeUsageSem.release();
};

bool ResourceManager::useOrReserve(const std::unordered_map<std::string, unsigned int>& usage,
        std::unordered_map<std::string, size_t>& assignedKeys,
        std::unordered_set<std::string>& constraints) {
    /*  Attempt to allocate and use resources, returning the keys generated by the use of
        the resources. If unable to allocate resources due to insufficient capacity, reserves the
        usage and populates constraints instead.
    */
    size_t key;
    constraints.clear();
    
    for (const auto& [ID, units]: usage) {
        if (this->resources[ID].hasFreeCapacity(units, &key)) {
            assignedKeys[ID] = key;
        } else {
            constraints.insert(ID);
        }
    }

    // Resource allocation success
    if (constraints.empty())
        return true;

    // Resource allocation failure: reserve usage
    for (const auto& [ID, units]: usage) {
        this->reservedUsage[ID] += units;
    }

    assignedKeys.clear();

    return false;
};

bool ResourceManager::useReservedOrUpdate(const std::unordered_map<std::string, unsigned int>& usage,
        std::unordered_map<std::string, size_t>& assignedKeys,
        std::unordered_set<std::string>& constraints) {
    /* Atttempt to allocate and use resources, returning the keys generated by the use of
        the resources. This method assumes that there was prior allocation failure, and the usage
        has already been reserved (see useOrReserve).
    */
    size_t key;
    std::string ID;

    for (auto setIter = constraints.cbegin(); setIter != constraints.cend(); ) {
        ID = *setIter;

        if (this->resources[ID].hasFreeCapacity(usage.at(ID), &key)) {
            assignedKeys[ID] = key;
            setIter = constraints.erase(setIter);
        } else {
            setIter ++;
        }
    }

    if (constraints.empty()) {
        

        return true;
    }

    assignedKeys.clear();
    return false;
};



void ResourceManager::update(std::unordered_set<std::string>& updatedResources) {
    this->freeUsageSem.acquire();

    for (auto mapIter = this->freedUsage.cbegin(); mapIter != this->freedUsage.cend(); ) {
        auto [ID, key] = mapIter->first;
        this->resources[ID].free(key, mapIter->second);
        updatedResources.insert(ID);

        mapIter = this->freedUsage.erase(mapIter);
    }

    this->freeUsageSem.release();
};
